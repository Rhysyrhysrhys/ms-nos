{"name":"Ms-nos","tagline":"A simple network operating system for Microservices (java implementation)","body":"ms-nos\r\n======\r\n\r\nA [simple network operating system](http://msnos.io) for Microservices (java implementation). This is a work in progress, the first public stable release will be available on Apr 15, 2015, however you are welcome to start experimenting right now, everything works (well, almost!): any queries, please open [an issue](https://github.com/workshare/ms-nos/issues) \r\n\r\n[![Built with Maven](http://maven.apache.org/images/logos/maven-feather.png)](http://maven.apache.org/)  [![Build Status](https://travis-ci.org/workshare/ms-nos.svg?branch=master)](https://travis-ci.org/workshare/ms-nos)\r\n<!--\r\n[![Coverage Status](https://coveralls.io/repos/bbossola/ms-nos/badge.png)](https://coveralls.io/r/workshare/ms-nos)\r\n--> \r\n\r\n## Summary\r\nMSNOS is a library built in order to mantain and survive a microservice based architecture :) Every microservice will surface spontaneously in a cloud, without the need of any application configuration. An application level healtcheck is available to internal monitor the health on the services in the cloud.\r\nMore on the website at http://msnos.io\r\n\r\n#### What is the context?\r\n- you use a microservice architecture\r\n- microservice are distributed across the world\r\n- each microservice provide different APIs\r\n- several instances of the same microservices are available\r\n\r\n#### What do we achieve?\r\n- new microservices capable to serve certain APIs are automatically recognized and used by every other microservice\r\n- if any microservice become unhealthy it stops receiving calls\r\n- no single point of failures \r\n- the load is distributed torugh advanced strategies (load, location, availability...)\r\n- add and/or remove of a new microservices is fully transparent\r\n\r\n#### How do I publish a new microservice?\r\nThe microservice will \"join\" a cloud and then publish his own APIs to the cloud: every other microservice will automatically discover them. Sample code:\r\n```\r\n  // create a cloud and join it\r\n  cloud = new Microcloud(new Cloud(params.uuid(), params.signature()));\r\n  self = new Microservice(params.name());\r\n  self.join(cloud);\r\n\r\n  // publish to the cloud myendpoints\r\n  RestApi[] { apis = new RestApi[] {\r\n    new RestApi(\"/hello\", port),\r\n    new RestApi(\"/wassup\", port),\r\n    new RestApi(\"/health\", port).asHealthCheck(),\r\n    new RestApi(\"/msnos\", port, Type.MSNOS_HTTP),\r\n  };\r\n  self.publish(apis);\r\n```\r\n\r\n#### How do a microservice find the best API to use?\r\nEach node in an msnos powered system mantains a full list of all available APIs and it's capable to select the best one for your call using strategies based on location, load and availability. Sample code:\r\n```\r\n  api = cloud.find(self, '/hello')\r\n```\r\n\r\n#### How do I expose some APIs to the external world?\r\nA [fast http non-blocking i/o proxy](https://github.com/workshare/ms-nos-proxy) is available out of the box, and it will automatically expose any public API of the cloud to the external world\r\n\r\n#### How does all this work?\r\nAn internal messaging system is used internally, basedon UDP and HTTP. An [http relay](https://github.com/workshare/ms-nos-www) needs to be installed in case your cloud is distribuited across different networks. Advanced microservices can expose an endpoint to accept MSNOS messages directly, as you can see in the [java example](https://github.com/workshare/ms-nos-usvc-client) provided, and briefly in this sample code: \r\n\r\n```\r\n  public void handle(HttpExchange exchange) throws IOException {\r\n    Reader reader = new BufferedReader(...);\r\n    try {\r\n      Message message = serializer.fromReader(reader, Message.class);\r\n      cloud.process(message, Endpoint.Type.HTTP);\r\n    } finally {\r\n      reader.close();\r\n    }\r\n    exchange.sendResponseHeaders(200, 0);\r\n    exchange.getResponseBody().close();\r\n  }\r\n```\r\nAs set of pre-build endpoints, in the form of jar dependencies, will be provided for the most common Java implementation (JavaSE, JavaEE, Jetty, Netty) and languages (.NET, Ruby)\r\n\r\n#### Are there working examples?\r\nThe [proxy](https://github.com/workshare/ms-nos-proxy) itself is a working example, but there's a also a [much simple client](https://github.com/workshare/ms-nos-usvc-client) that you can checkout and look at. Examples in other languages will be provided as soon as we will upgrade a microservice sin the same technology.\r\n\r\n#### Are other languages supported?\r\nThe protocol is completely language agnostic (heck, it's json!) and we build microservices in a lot of different languages. A Ruby implementation is in the work, a .NET binary will be realeased (as soon as it clears QA) and a Javascript version will be available soon.\r\n\r\n## Commmon Q&A\r\nThose are most of the common question we are asked when presenting our solution to the public: it's quite possibile you will find the answer to your question here, but if you don't please feel free to [open an issue](https://github.com/workshare/ms-nos/issues)\r\n\r\n#### Why don't you simply use a dynamic DNS to manage discovery?\r\nWell, first of all a DNS entry does not provide us enough granularity, as we want to tall about API endpoints, not machines names. Even when this is acceptable, there are other very good reasons to avoid doing that, such as:\r\nWe consider it a naive approach\r\n- the clients will have poll forchanges as thereâ€™s no push protocol for DNS\r\n- any DNS suffer from propagation delays, which is also non deterministic\r\n- the routing will be effectively random, as there's no way for a DNS to dynamically assess the status of an API endpoint \r\n- aggressive DNS caching may take place by client libraries or even applications at startup (i.e. Nginx / HAProxy) thus making ineffective anything done at the DNS level \r\n\r\n#### Why don't you use ${other-framework}?\r\nWell, there are different answer for each of them, and such frameworks are becoming more popular by the minute! Anyway, some common issues we found so far:\r\n- they do not have native API level granularity (i.e. Consul,  Zookeper)\r\n- they do not have a push model (i.e. Zookeper, dynamic DNS)\r\n- they have a single point of failre and are not fully distributed (Smartstack)\r\n- they are missing basic necessary routing mechanism (i.e. geolocation, session stickiness)\r\n- they are not language agnostic or very difficult to code against (i.e. Zookeper)\r\n- they are proprietary\r\n\r\n## License\r\nReleased under the MIT License.  See the [LICENSE](LICENSE) file for further details.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}